AngularJS has a very useful feature: HTTP Interceptors, these ones are services that get automatically called on each ajax request step (before an ajax call, after an ajax call and so on) once they are registered using the $httpProvider.

So what I do in my app is to create the following interceptor:

```angular.module('myapp').
    service('LoadingInterceptor', 
    ['$q', '$rootScope', '$log', 
    function($q, $rootScope, $log) {
        'use strict';
 
        return {
            request: function(config) {
                $rootScope.loading = true;
                return config;
            },
            requestError: function(rejection) {
                $rootScope.loading = false;
                $log.error('Request error:', rejection);
                return $q.reject(rejection);
            },
            response: function(response) {
                $rootScope.loading = false;
                return response;
            },
            responseError: function(rejection) {
                $rootScope.loading = false;
                $log.error('Response error:', rejection);
                return $q.reject(rejection);
            }
        };
    }]);
```

It makes use of $rootScope to store the loading state “globally”, which is set to true as soon the request is created (request method) and set to false when the request is invalid (requestError) or the call has been completed (response or responseError).
It also logs errors in case of requestError and responseError.
Then I register the interceptor in the module config() block:

``` 
.config(['$httpProvider', function($httpProvider) {

    $httpProvider.interceptors.push('LoadingInterceptor');
    
}]);
```

As you can see it’s registered as a simple plain string rather than using the usual dependency injection (AngularJS knows how to properly load the service).
Regarding the display of a message/spinner to the user, in my templates all I have to do is something like:
``` 
<div data-ng-if="loading">
    Loading...
</div
```
